h[["foo"]] <- "bar"
h[["4"]] <- list(a=1, b=2)
# get values
h[["1"]]
## [1] 42
h[["4"]]
## $a
## [1] 1
##
## $b
## [1] 2
h[c("1", "foo")]
speciesEADDC_Dict <- hash()
# set values
speciesEADDC_Dict[["pomonella2020.grd"]] <- 607.60
h[["pomonella2020.grd"]]
h[["foo"]] <- "bar"
h[["foo"]]
speciesEADDC_Dict[["pomonella2020.grd"]]
make.names("Cydia Pomonella")
?make.names
runApp()
#use make.names
availablePhenoSpecies <- list("Cydia Pomonella" = "pomonella2020.grd",
"Aphis Gossypii" = "Aphis_gossypii_DD.grd")
availablePhenoSpecies
runApp()
updateGHCNDStations <- function(){stationsDailyRaw <- read.fwf(url("https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt"),
widths = c(11, 9, 11, 7, 2, 31, 5, 10),
header = FALSE, strip.white = TRUE, comment.char = "",
stringsAsFactors = FALSE)
inventoryDailyRaw <- read.fwf(url("https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-inventory.txt"),
widths = c(11, 9, 10, 5, 5, 5),
header = FALSE, strip.white = TRUE, comment.char = "",
stringsAsFactors = FALSE)
stationColNames <- c("id","latitude", "longitude", "elevation",
"state", "name", "gsn_flag", "wmo_id")
inventoryColNames <- c("id","latitude", "longitude",
"element", "first_year", "last_year")
ghcndStationsDaily <- stats::setNames(stationsDailyRaw, stationColNames)
ghcndInventoryDaily <- stats::setNames(inventoryDailyRaw, inventoryColNames)
ghcndStationsDailyComplete <- merge(ghcndStationsDaily, ghcndInventoryDaily[, -c(2, 3)], by = "id")
sturdyGHCNDStations <- tibble::as_tibble(ghcndStationsDailyComplete[stats::complete.cases(ghcndStationsDailyComplete), ])
saveRDS(sturdyGHCNDStations, file = "./ghcnd-stations-current.csv")
return(sturdyGHCNDStations)}
updateGHCNDStations
updateGHCNDStations()
runApp()
as.name("pomo 2020")
make.names("pomo 2020")
make.names("pomo 2020", ".grd")
make.names(as.Date('2020-01-01'))
str_c(make.names(as.Date('2020-01-01')), ".txt")
runApp()
#Species name and corresponding filename
availablePhenoSpecies <- list("Cydia Pomonella" = "./dat/pomonella2020.grd",
"Aphis Gossypii" = "./dat/Aphis_gossypii_DD.grd")
next <- list(availablePhenoSpecies, "more" = "more")
next <- list(availablePhenoSpecies, "more" = "5")
append(availablePhenoSpecies, "more" = 15)
append(availablePhenoSpecies, c("more" = 15))
append(availablePhenoSpecies, c("Aphis Gossypii" = 15))
?append
availablePhenoSpecies[["Aphis Gossypii" = NULL]]
availablePhenoSpecies[["Aphis Gossypii"]] <- NULL
NULL
availablePhenoSpecies[["Aphis Gossypii"]] <- NULL
availablePhenoSpecies
#Species name and corresponding filename
availablePhenoSpecies <- list("Cydia Pomonella" = "./dat/pomonella2020.grd",
"Aphis Gossypii" = "./dat/Aphis_gossypii_DD.grd")
write_rds(availablePhenoSpecies, "./dat/")
write_rds(availablePhenoSpecies, "./dat/availablePhenoSpecies.csv")
read_rds("./dat/availablePhenoSpecies.csv")
speciesEADDC_Dict <- hash()
# set values of EADDC for use in lookup when adding rasterImage (make sure to add EADDCs for any extra species)
speciesEADDC_Dict[["./dat/pomonella2020.grd"]] <- 607.60
speciesEADDC_Dict[["./dat/Aphis_gossypii_DD.grd"]] <- 102.3121
write_rds(speciesEADDC_Dict, "./dat/phenoSpeciesEADDC.csv")
read_rds("./dat/phenoSpeciesEADDC.csv")
?write_rds
runApp()
#-----Define species to visualize phenology with, locations of species' rasterStacks, and EADDC value used in computation of rasterStack
speciesEADDC_Dict <- read_rds("./dat/phenoSpeciesEADDC.csv")
#Species name and corresponding filename
availablePhenoSpecies <- read_rds("./dat/availablePhenoSpecies.csv")
is.null(availablePhenoSpecies[["gos"]])
runApp()
dict <- hash()
dict[["hello"]] <- 10
dict[["goodbye"]] <- 15
values(dict)
head(values(dict))
list(hello = 15)
list(hello = 15, goodbye = 20)
atest <- list(hello = 15, goodbye = 20)
atest
u = atest > 5
u
u = if(atest > 5){names(atest)}
u
u = if(atest > 15){names(atest)}
u
atest
atest[1]
atest[[1]]
names(atest[1])
#-----Define species to visualize phenology with, locations of species' rasterStacks, and EADDC value used in computation of rasterStack
speciesEADDC_Dict <- read_rds("./dat/phenoSpeciesEADDC.csv")
#Species name and corresponding filename
availablePhenoSpecies <- read_rds("./dat/availablePhenoSpecies.csv")
pomo <- raster::stack(./dat/pomonella2020.grd)
pomo <- raster::stack('./dat/pomonella2020.grd')
aphis <- raster::stack('./dat/Aphis_gossypii_DD.grd')
pomo
toSave = list(
"./dat/pomonella2020.grd" = as.Date('2020-06-01'),
"./dat/Aphis_gossypii_DD.grd" = as.Date('2020-06-01')
)
toSave
toSave = list(
"./dat/pomonella2020.grd" = as.Date('2020-06-01'),
"./dat/Aphis_gossypii_DD.grd" = as.Date('2020-06-02')
)
write_rds(toSave, "./dat/forecastAge.csv")
last <- as.Date('2020-05-28')
difftime(last, Sys.Date(), units = "days")
last - Sys.Date()
as.numeric(last - Sys.Date())
as.numeric(Sys.Date() - last)
length(pomo)
?raster()
nbands(pomo)
bandnr(pomo)
nlayers(pomo)
pomo
pomo[22]
raster(pomo, band = 22)
raster(pomo, band = 21)
?raster
raster(pomo, layer = 21)
raster(pomo, layer = 22)
raster(pomo, layer = nlayers(pomo))
#Species name and corresponding filename
availablePhenoSpecies <- read_rds("./dat/availablePhenoSpecies.csv")
availablePhenoSpecies
invert(availablePhenoSpecies)
names(availablePhenoSpecies)
names(availablePhenoSpecies)[availablePhenoSpecies == "./dat/Aphis_gossypii_DD.grd"]
updatePhenology <- function(ageDict = read_rds("./dat/forecastAge.csv")){
for (i in ageDict) {
if(as.numeric(Sys.Date() - ageDict[[i]]) >= 7){
toUpdate <- raster::stack(names(ageDict[[i]]))
accumulateDD(ageDict[[i]],
species = names(availablePhenoSpecies)[availablePhenoSpecies == names(ageDict[[i]])],
cum_DD = raster(toUpdate, layer = nlayers(toUpdate)))
}
}}
updatePhenology()
ageDict = read_rds("./dat/forecastAge.csv"
)
updatePhenology <- function(ageDict = read_rds("./dat/forecastAge.csv")){
for (i in ageDict[]) {
if(as.numeric(Sys.Date() - ageDict[[i]]) >= 7){
toUpdate <- raster::stack(names(ageDict[[i]]))
accumulateDD(ageDict[[i]],
species = names(availablePhenoSpecies)[availablePhenoSpecies == names(ageDict[[i]])],
cum_DD = raster(toUpdate, layer = nlayers(toUpdate)))
}
}}
updatePhenology()
updatePhenology <- function(ageDict = read_rds("./dat/forecastAge.csv")){
for (i in ageDict) {
print(ageDict)
if(as.numeric(Sys.Date() - ageDict[[i]]) >= 7){
toUpdate <- raster::stack(names(ageDict[[i]]))
accumulateDD(ageDict[[i]],
species = names(availablePhenoSpecies)[availablePhenoSpecies == names(ageDict[[i]])],
cum_DD = raster(toUpdate, layer = nlayers(toUpdate)))
}
}}
updatePhenology()
updatePhenology <- function(ageDict = read_rds("./dat/forecastAge.csv")){
for (i in ageDict) {
print(ageDict[[1]])
if(as.numeric(Sys.Date() - ageDict[[i]]) >= 7){
toUpdate <- raster::stack(names(ageDict[[i]]))
accumulateDD(ageDict[[i]],
species = names(availablePhenoSpecies)[availablePhenoSpecies == names(ageDict[[i]])],
cum_DD = raster(toUpdate, layer = nlayers(toUpdate)))
}
}}
updatePhenology()
ageDict[1]
values(ageDict)
ageDict[[]]
ageDict[
]
ageDict[][]
unlist(ageDict)
unlist(ageDict)[1]
unlist(ageDict)[2]
unlist(ageDict)[,2]
unlist(ageDict)[[1]]
length(ageDict)
unlist(ageDict)[[1:length(ageDict)]]
unlist(ageDict)[[c(1:length(ageDict))]]
names(ageDict) <- NULL
ageDict
unlist(ageDict)
unlist(ageDict)[1]
unlist(ageDict)[2]
as.vector(ageDict)
unlist(as.vector(ageDict))
runApp()
accumulateDD('2020-01-01', species = "Acyrthosiphon pisum")
accumulateDD('2020-01-01', species = "Acyrthosiphon pisum")
accumulateDD('2020-01-01', species = "Acyrthosiphon pisum")
accumulateDD('2020-01-01', species = "Acyrthosiphon pisum")
Q
Q
accumulateDD('2020-01-01', species = "Acyrthosiphon pisum")
setwd("~/Buckley_Lab/Insect-Phenology-Forecaster")
accumulateDD('2020-01-01', species = "Acyrthosiphon pisum")
View(get_dfWrangled)
get_dfWrangled <- function(){
#Import seasonality database
AppendixS3_SeasonalityDatabase <- read.csv("./dat/AppendixS3_SeasonalityDatabase.csv", header=TRUE)
#Selecting certain columns and creating mean_* columns
dfWrangled <-  as_tibble(AppendixS3_SeasonalityDatabase) %>%
dplyr::select(Species, Species.1, BDT.C, EADDC, lat, lon) %>%
group_by(Species.1) %>%
mutate(mean_BDT.C = mean(BDT.C, na.rm=TRUE),
mean_EADDC = mean(EADDC, na.rm=TRUE))
#Remove physiological outliers
dfWrangled = subset(dfWrangled, dfWrangled$BDT.C > -7 & dfWrangled$EADDC < 2000)
#Restrict to dat with lat / lon
dfWrangled = dfWrangled[which(!is.na(dfWrangled$lon) & !is.na(dfWrangled$lat) ),]
dfWrangled$uid <- seq.int(nrow(dfWrangled))
return(dfWrangled)}
#DEGREE DAYS CALCULATION
#Single sine wave approximation from Baskerville & Emin 1969
#(see http://www.ipm.ucdavis.edu/WEATHER/ddss_tbl.html)
#Input:
#Tdat: 2 column matrix with Tmin followed by Tmax
#LDT:lower developmental threshold
#------Adapted from Lauren Buckley (no longer allows for negative DDs and accepts NA values)
degree. days.mat=function(Tmin, Tmax, LDT){
# entirely above LDT
#|| is.null(Tmin) || is.null(Tmax)
if(is.na(Tmin) || is.na(Tmax) || is.null(Tmin) || is.null(Tmax)){dd = NA}
else{
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}}
return(dd)
}
#DEGREE DAYS CALCULATION
#Single sine wave approximation from Baskerville & Emin 1969
#(see http://www.ipm.ucdavis.edu/WEATHER/ddss_tbl.html)
#Input:
#Tdat: 2 column matrix with Tmin followed by Tmax
#LDT:lower developmental threshold
#------Adapted from Lauren Buckley (no longer allows for negative DDs and accepts NA values)
degree.days.mat=function(Tmin, Tmax, LDT){
# entirely above LDT
#|| is.null(Tmin) || is.null(Tmax)
if(is.na(Tmin) || is.na(Tmax) || is.null(Tmin) || is.null(Tmax)){dd = NA}
else{
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}}
return(dd)
}
#Required argument:
#   -     start_date: a date to begin accumulation at
#Optional arguments:
# Note: BDT and EADDC arguments must be specified if species is not specified
#       - end_date: a date to stop accumulation at (default: two days ago)
#       - BDT: either an integer BDT value or a vector of values to be averaged
#       - EADDC: either an integer EADDC value or a vector of values to be averaged
#       - cum_DD: a rasterLayer containing cumulative Degree Day values on the start date
#                 (Degree days will begin accumulating from here, otherwise they start at 0)
#       - species: a string species name that will be queried to get mean BDT and EADDC values from ./dat/AppendixS3_SeasonalityDatabase.csv
accumulateDD <- function(start_date, end_date = Sys.Date() -2, BDT = NULL, EADDC = NULL, cum_DD = NULL, species = NULL){
#Define area of interest
if(!is.Date(start_date)){start_date <- as.Date(start_date)}
if(!is.Date(end_date)){end_date <- as.Date(end_date)}
if((is.null(BDT) || is.null(EADDC)) && is.null(species)){return("Please provide BDT and EADDC arguments, or a species to query")}
if(!is.null(species)){
toAccumulate <- get_dfWrangled() %>% filter(Species == species)
print(str_c("Species selected: ", species))
print("BDT Values Found: ")
print(toAccumulate$BDT.C)
BDT <- mean(toAccumulate$BDT.C)
print(str_c("Average BDT: ", BDT))
print("EADDC Values Found: ")
print(toAccumulate$EADDC)
EADDC <- mean(toAccumulate$EADDC)
print(str_c("Average EADDC: ", EADDC))}
#Find means of BDT and EADDC if vector of either is passed in
if(length(BDT) > 1){
print(str_c("Averaging BDTs: ", BDT))
BDT <- mean(BDT)
print(str_c("Average BDT: ", BDT))}
if(length(EADDC) > 1){
print(str_c("Averaging EADDCs: ", EADDC))
EADDC <- mean(EADDC)
print(str_c("Average EADDC: ", EADDC))}
print(str_c("BDT: ", BDT, ", EADDC: ", EADDC))
AOI = aoi_get(state = "conus")
#Get temp raster stack for start_date
#raster::plot(AOI)
print(start_date)
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = start_date)
r = raster::stack(p$tmax, p$tmin)
names(r) = c('tmax', 'tmin')
#print("not above here")
#Initialize cum_DD to DD values for start_date
if(is.null(cum_DD)){
#print("initializing")
cum_DD <- calc(r, fun = function(x){
#print(value(x[2]))
degree.days.mat(value(x[2]) -273.15, value(x[1]) -273.15, BDT)})
}
print(cum_DD)
# cum_DD <- calc(r, fun = function(x){
#   degree.days.mat(x[2] / 10, x[1] / 10, BDT)})
#Set current day to the next start day
week <- 1
current_date = start_date + 1
the_stack <- NULL
#Accumulate Degree Days from current_date to end_date, inclusive.
while(current_date <= end_date){
#Get raster stack of tmin and tmax for current day
temps = getGridMET(AOI, param = c('tmax','tmin'), startDate = current_date)
tstack = raster::stack(temps$tmax, temps$tmin)
names(tstack) = c('tmax', 'tmin')
print(current_date)
#Calculate todays DD values
current_DD <- calc(tstack, fun = function(x){degree.days.mat(value(x[2]) -273.15, value(x[1]) -273.15, BDT)})
#print(identical(current_DD, cum_DD))
names(current_DD) = c(current_date)
#Add cumulative DD values to current_date DD values (current_DD)
cum_DD <- cum_DD + current_DD
#Reset cum_DD values greater than EADDC to 0
cum_DD <- calc(cum_DD, fun = function(cumul){
if (!is.na(cumul[1]) && (cumul[1] >= EADDC)){
return(as.vector(EADDC))}
else {
return(cumul[1])}})
#Increment current_date
names(cum_DD) = c(current_date)
week <- week + 1
current_date = current_date + 1
if(week == 7){
the_stack <- raster::stack(cum_DD)
print(the_stack)
print(names(the_stack))
}
if(week == 14){
#if(is.null(the_stack)){the_stack = raster::stack("holdraster.grd")}
the_stack <- raster::stack(the_stack, cum_DD)
#writeRaster(the_stack, "holdraster.grd", overwrite=TRUE)
print(the_stack)
print(names(the_stack))
#the_stack <- NULL
week <- 7
}
}
#Update ./dat/availablePhenoSpecies.csv and ./dat/phenoSpeciesEADDC.csv with new species entry
if(!is.null(species)){
filePath <- str_c("./dat/", make.names(species), ".grd")
availablePhenoSpecies <- read_rds("./dat/availablePhenoSpecies.csv")
if(!is.null(availablePhenoSpecies[[species]])){availablePhenoSpecies[[species]] <- NULL}
else{
speciesEADDC_Dict <- read_rds("./dat/phenoSpeciesEADDC.csv")
speciesEADDC_Dict[[filePath]] <- EADDC
write_rds(speciesEADDC_Dict, "./dat/phenoSpeciesEADDC.csv")}
#Add species to available list
availablePhenoSpecies <- append(availablePhenoSpecies, c(species = filePath))
write_rds(availablePhenoSpecies, "./dat/availablePhenoSpecies.csv")}
else{filePath <- str_c("./dat/", make.names(current_date), ".grd")}
#Save the raster to the dat folder
writeRaster(the_stack, filePath, overwrite=TRUE)
return(the_stack)
#raster::plot(newR)
}
accumulateDD('2020-01-01', species = "Acyrthosiphon pisum")
accumulateDD('2020-01-01', species = "Acyrthosiphon kondoi")
accumulateDD('2020-01-01', species = "Agrotis ipsilon")
install.packages("forecast")
?switchInput
runApp()
runApp()
?useShinyjs
library('shinyjs')
library(shinyjs)
install.packages("shinyjs")
library('shinyjs')
library(shinyjs)
?useShinyjs
?includeMarkdown
library(shiny)
library(leaflet)
#library(dplyr)
#library(tidyr)
library(mosaic)
library(rnoaa)
library(shinyWidgets)
#library(ggplot2)
library(lubridate)
#library(leafpop)
library(taxize)
#library(rgeos)
#library(sf)
library(raster)
library(rasterVis)
#library(sp)
library(tidyverse)
library(hash)
library(shinycssloaders)
library(rgdal)
remotes::install_github("mikejohnson51/AOI")
remotes::install_github("mikejohnson51/climateR")
library(AOI)
library(climateR)
runApp()
runApp()
runApp()
While many insects' life cycles vary greatly from one another, a wholistic interpretation of this life cycle allows for intriguing developmental comparisons to be made between insect species. This visualization will interpret the insect developmental process, specifically **spring phenology**, as a period of time from the insect's egg stage to its emergence as an adult, encompassing other, distinct intermediate stages.
**Growing degree days (GDD)** are one metric ecologists can use to understand spring phenology in insects. In other words, insects can be thought of as reaching adulthood after they have accumulated a sufficient amount of thermal energy for their emergence to occur. At first glance, this method may seem overly general, as it is well understood that thermal tolerances vary greatly between species. However, incorporating [previously collected data](https://github.com/lbuckley/ICBseasonality/tree/master/CodeForICBPaper) on individual species' developmental temperature thresholds allows for the calculation of GDDs for a target species. The [TrenchR](https://github.com/trenchproject/TrenchR) package's degree day function combines species-specific baseline developmental temperatures with daily temperature minima (**T_min**) and maxima (**T_max**) to calculate the GDDs accumulated in a 24 hour period:
runApp()
class(NULL)
NULL
class(NULL)
class(NA)
runApp()
runApp()
runApp()
runApp()
runApp()
?ifelse
runApp()
runApp()
c(5, 10, 15, 20)
c(5, 10, 15, 20) == 1
(c(5, 10, 15, 20)) == 1
notone <- (5, 10, 15, 20)
notone <- c(5, 10, 15, 20)
identical(notone ,1)
identical(1 ,1)
runApp()
runApp()
?addLegend
?labelFormat
?labelForma
?labelFormat
runApp()
runApp()
labelFMT <- function (type, ...)
{
switch(type, numeric = (function(cuts) {
paste0(prefix, formatNum(cuts), suffix)
})(...), bin = (function(cuts) {
n <- length(cuts)
paste0(prefix, formatNum(cuts[-n]), between, formatNum(cuts[-1]),
suffix)
})(...), quantile = (function(cuts, p) {
n <- length(cuts)
p <- paste0(round(p * 100), "%")
cuts <- paste0(formatNum(cuts[-n]), between, formatNum(cuts[-1]))
paste0("<span title=\"", cuts, "\">", prefix, p[-n],
between, p[-1], suffix, "</span>")
})(...), factor = (function(cuts) {
paste0(prefix, as.character(transform(cuts)), suffix)
})(...))
}
View(labelFMT)
?switch
runApp()
runApp()
runApp()
runApp()
runApp()
?labelFormat
runApp()
runApp()
library(waiter)
install.packages("waiter")
library(waiter)
runApp()
source("https://install-github.me/mangothecat/shinytoastr")
install.packages("shinyhelper")
runApp()
?getBCSDvic
