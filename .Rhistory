# entirely above LDT
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}
return(dd)
}
# cumsum with reset adapted from @jgilfillan on github, many thanks!
cumsum_with_reset <- function(x, threshold) {
cumsum <- 0
group <- 1
result <- numeric()
for (i in 1:length(x)) {
if (cumsum == threshold){
group <- group + 1
cumsum <- 0
}
cumsum <- cumsum + x[i]
if (cumsum > threshold) {
cumsum <- threshold
}
result = c(result, cumsum)
}
return (result)
}
#-----Graphing Helper Functions---------
dd_plot <- function(tMax1, tMax2, tMin1, tMin2, BDT, EADDC, startTime, breaks = NULL, dateformat='%d/%m/%y') {
UseMethod("dd_plot")
}
dd_plot.tbl_df <- function(tMax1, tMax2, tMin1, tMin2, BDT, EADDC, startTime, breaks = NULL, dateformat='%d/%m/%y') {
#Making a new dataframe that has all of tMax1 and tMax2 for missing dates
if(!is.na(tMax1) && !is.na(tMax2) && !is.na(tMin1) && !is.na(tMin2)) {
dfTMAX <- rbind(tMax1, tMax2[!tMax2$date %in% tMax1$date,])
dfTMIN <- rbind(tMin1, tMin2[!tMin2$date %in% tMin1$date,])
} else {
dfTMAX <- rbind(tMax1, tMax2)
dfTMIN <- rbind(tMin1, tMin2)
}
#Cleaning up dates
dfTMAX$date <- ymd(sub('T00:00:00\\.000|T00:00:00', '', as.character(dfTMAX$date)))
dfTMIN$date <- ymd(sub('T00:00:00\\.000|T00:00:00', '', as.character(dfTMIN$date)))
#Order dataframe by date
dfTMAX <- dfTMAX[order(as.Date(dfTMAX$date, format = "%y%m%d")),]
dfTMIN <- dfTMIN[order(as.Date(dfTMIN$date, format = "%y%m%d")),]
#value = NULL
#Joining TMIN and TMAX data into dfTEMP
dfTEMP <- full_join(dfTMAX, dfTMIN[ , c("date", "TMIN")], by = 'date')
#Matching units and removing errors
dfTEMP$TMAX[which(dfTEMP$TMAX==-9999)]= NA
dfTEMP$TMAX= dfTEMP$TMAX/10 #correct for tenths of degrees or mm
dfTEMP$TMIN[which(dfTEMP$TMIN==-9999)]= NA
dfTEMP$TMIN= dfTEMP$TMIN/10 #correct for tenths of degrees or mm
#Catch other NA values
#Comment back in ============================
dfTEMP$TMAX[which(dfTEMP$TMAX > 200)] = NA
dfTEMP$TMIN[which(dfTEMP$TMIN > 200)] = NA
dfTEMP$TMAX[which(dfTEMP$TMAX < -200)] = NA
dfTEMP$TMIN[which(dfTEMP$TMIN < -200)] = NA
#===============================================
#Calculating degree days in a new column in dDays
# dDays <- dfTEMP %>%
#     mutate (dd = degree.days.mat(TMIN, TMAX, BDT)) %>%
#split year
#  date= as.Date(dfTEMP$date, "%Y-%m-$d")
#  dfTEMP$year=as.numeric(format(date, "%Y"))
## FIND YEARS WITH NEARLY COMPLETE DATA
# dat.agg= aggregate(dfTEMP, list(dfTEMP$year),FUN=count)  ### PROBLEM IF RASTER LOADED
# years= dat.agg$Group.1[which(dat.agg$TMAX>50)]
# dfTEMP= dfTEMP[which(dfTEMP$year %in% years),]
#na.omit()
dfTEMP <- na.omit(dfTEMP)
dfTEMP$dd <- NA
for (i in 1:nrow(dfTEMP)) {
dd = degree.days.mat(dfTEMP$TMIN[i], dfTEMP$TMAX[i], BDT)
dfTEMP$dd[i] <- dd
}
# dDays = dfTEMP %>% na.omit()
dDays <- dfTEMP
#Adding a csum column which sums degree days and resets after reaching threshold (EADDC)
dDays$csum <- cumsum_with_reset(dDays$dd, EADDC)
#Plot csum vs date
ggplot(dDays, aes(date, csum)) +
plot_template(df, breaks, dateformat) +
ncdc_theme() +
geom_hline(aes(yintercept = EADDC), linetype = "dashed", color = "green") +
geom_text(aes( startTime, EADDC, label = "EADDC", vjust = +1.5, hjust = -0.1), size = 3)
#scale_y_continuous(breaks = sort(c(ggplot_build(plot1)$layout$panel_ranges[[1]]$y.major_source, h)))
}
dd_plot.default <- function(tMax1, tMax2, tMin1, tMin2, BDT, EADDC, startTime, breaks = NULL, dateformat = '%d/%m/%y') {
stop("No method for ", class(list(tMax1)[[1]]), call. = FALSE)
}
plot_template <- function(df, breaks, dateformat) {
tt <- list(
theme_bw(base_size = 18),
geom_line(size = 2),
labs(y = "Cumulative Degree Days", x = "Date")
)
if (!is.null(breaks)) {
c(tt, scale_x_date(date_breaks = breaks, date_labels = dateformat))
} else {
tt
}
}
#Fetch a common name for a species or return "No available common name." if no results found
safeSci2Com <- function(df) {
com <- sci2comm(df, db = "eol", simplify = TRUE) %>%
flatten()
if(identical(com, list())){
com <- "No available common name."
} else {
#fcom <- flatten(com)
com <- com[[1]]
}
return(com)
}
#-----It's the user interface! (What the user sees)-------
ui <- fluidPage(
headerPanel('Insect Phenology Visualization'),
sidebarPanel(
multiInput('sel_species',
'Select species: ',
choices = as.vector(unique(speciesStationDF$Species.1)),
selected = unique(speciesStationDF$Species.1)),
actionButton("all", "All"),
actionButton("none", "None"),
#actionButton("execute","Execute"),
# actionButton("updateDateRange", "View"),
#  hr(),
verbatimTextOutput(outputId = "pltInf", placeholder = FALSE),
dateRangeInput(inputId = "dateRange",
label = "Change date range: ",
start  = "2020-01-01",
min    = "1900-01-01",
format = "mm/dd/yy",
separator = " - "),
plotOutput("predPlot", height = 300)
),
mainPanel(
leafletOutput("mymap", height = 600)
)
)
#------Here is the server for the shiny app (How the page becomes responsive)--------
server <- function(input, output, session){
#Create a reactive dataframe which changes based on the selected species from the multi input tool
lat_long_df <- reactive({
x <- speciesStationDF %>%
filter(Species.1 %in% input$sel_species)
})
#Listen for a button click (all or none) and change selections accordingly
observeEvent(input$all, {
updateMultiInput(
session = session,
inputId = "sel_species",
selected = unique(speciesStationDF$Species.1)
)
})
observeEvent(input$none, {
updateMultiInput(
session = session,
inputId = "sel_species",
selected = character(0)
)
})
timeRange <- reactive({
x <- input$dateRange
})
#If a user selects a circle marker, the phenology prediction plot for that insect will appear in the sidebar panel.
#If the user changes timeRange(), and has already selected an observation from the map. The plot will update with new data.
observeEvent({
input$mymap_marker_click
timeRange()
}, {
click<-input$mymap_marker_click
uid <- click$id
if(!is.null(uid)){
time <- timeRange()
output$pltInf <- renderPrint(safeSci2Com(speciesStationDF$Species[uid]))
tMax1 <- ncdc(datasetid='GHCND',
stationid= paste0('GHCND:', speciesStationDF$sid1[uid]),
datatypeid= "TMAX",
startdate = time[1],
enddate = time[2],
limit=500,
token="HnmvXmMXFNeHpkLROUmJndwOyDPXATFJ")
tMax2 <- ncdc(datasetid='GHCND',
stationid= paste0('GHCND:', speciesStationDF$sid2[uid]),
datatypeid= "TMAX",
startdate = time[1],
enddate = time[2],
limit=500,
token="HnmvXmMXFNeHpkLROUmJndwOyDPXATFJ")
ifelse(nrow(tMax1$data)==0,
tMax1 <- NA,
tMax1 <- tMax1$data %>% dplyr::select(date, value) %>% rename(TMAX = value)
)
ifelse(nrow(tMax2$data)==0,
tMax2 <- NA,
tMax2 <- tMax2$data %>% dplyr::select(date, value) %>% rename(TMAX = value)
)
tMin1 <- ncdc(datasetid='GHCND',
stationid= paste0('GHCND:', speciesStationDF$sid1[uid]),
datatypeid= "TMIN",
startdate = time[1],
enddate = time[2],
limit=500,
token="HnmvXmMXFNeHpkLROUmJndwOyDPXATFJ")
tMin2 <- ncdc(datasetid='GHCND',
stationid= paste0('GHCND:', speciesStationDF$sid2[uid]),
datatypeid= "TMIN",
startdate = time[1],
enddate = time[2],
limit=500,
token="HnmvXmMXFNeHpkLROUmJndwOyDPXATFJ")
ifelse(nrow(tMin1$data)==0,
tMin1 <- NA,
tMin1 <- tMin1$data %>% dplyr::select(date, value) %>% rename(TMIN = value)
)
ifelse(nrow(tMin2$data)==0,
tMin2 <- NA,
tMin2 <- tMin2$data %>% dplyr::select(date, value) %>% rename(TMIN = value)
)
if(!is.na(tMax1) && !is.na(tMax2))
{output$predPlot <- renderPlot(
dd_plot(tMax1,
tMax2,
tMin1,
tMin2,
speciesStationDF$BDT.C[uid],
speciesStationDF$EADDC[uid],
time[1],
breaks="1 month",
dateformat="%m/%d"))}
else {output$pltInf <- renderPrint("No current RNOAA data available here.")}
} else {
output$pltInf <- renderPrint("Select an observation from the map.")
}
})
#-------Create map, add circle markers and popup-------
AOI = aoi_get(state = "conus")
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = "2018-8-15")
q = getGridMET(AOI, param = c('tmin'), startDate = "2018-8-15")
r = raster::stack(p$tmax, p$tmin)
names(r) = c('tmax', 'tmin')
a = raster(q$tmin)
rasterVis::levelplot(a)
output$mymap <- renderLeaflet({
df <- lat_long_df()
map <- leaflet(data = df) %>%
addProviderTiles(providers$OpenTopoMap) %>%
#addTiles() %>%
addRasterImage(p$tmax, opacity = 0.8, group = "Oth") %>%
addCircleMarkers(lng = ~lon,
lat = ~lat,
radius = 1,
group = "Obs",
layerId = ~uid,
popup = paste("<em>",df$Species,"</em>", "<br>",
#sci2comm(df$Species)[[1]][1], "<br>",
"<b> EADDC: </b>", round(df$EADDC, digits=2), "<br>",
"<b> BDT.C: </b>", round(df$BDT.C, digits=2), "<br>",
"<b> SID: </b>", df$sid )) %>% #,
# popupGraph(ncdc_plot(ncdc(datasetid='GHCND',
#                           stationid=paste0('GHCND:', df$sid),
#                           datatypeid='tmax',
#                           startdate = '2020-01-01',
#                           enddate = '2020-05-21',
#                           limit=500,
#                           token="HnmvXmMXFNeHpkLROUmJndwOyDPXATFJ"),
#                      breaks="1 month",
#                      dateformat="%m/%d"),
#            width = 300,
#            height = 400))) %>%
setView(lng=-98.5795, lat=39.8283, zoom=4) %>%
addLayersControl(baseGroups = c("Obs", "Oth"),
options = layersControlOptions(collapsed = F))#%>%
map
})
}
#--------- Here, the shiny app is being executed--------
shinyApp(ui = ui, server = server)
runApp()
runApp()
AOI = aoi_get(state = "conus")
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = "2018-8-15")
q = getGridMET(AOI, param = c('tmin'), startDate = "2018-8-15")
r = raster::stack(p$tmax, p$tmin)
names(r) = c('tmax', 'tmin')
a = raster(q$tmin)
rasterVis::levelplot(a)
library(rasterVis)
rasterVis::levelplot(a)
rasterVis::levelplot(a)
rasterVis::levelplot(r)
View(a)
?raster
raster
a = raster(r)
rasterVis::levelplot(a)
?levelplot
rasterVis::plot(a)
raster::plot(a)
View(a)
?plot
raster::plot(a, main="Raster with 32 pixels")
raster::plot(a, maxpixels=500000)
rasterVis::levelplot(r)
View(r)
comp = calc(r, degree.days.mat(EADDC = 500, BDT=15))
comp = calc(r, degree.days.mat(LDT=15))
?list
comp = calc(r, degree.days.raster(LDT=15))
#Slightly modified version for use with raster calc function
degree.days.raster=function(cellVector, LDT){
Tmin = cellVector[1]
Tmax = cellVector[2]
# entirely above LDT
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}
return(dd)
}
comp = calc(r, degree.days.raster(LDT=15))
comp = calc(r, degree.days.raster(..., LDT=15))
comp = calc(r, degree.days.mat(x[1], x[2], LDT=15))
comp = calc(r, degree.days.raster(LDT=15))
#Slightly modified version for use with raster calc function
degree.days.raster=function(x, LDT){
Tmin = x[1]
Tmax = x[2]
#Tmin = cellVector[1]
#Tmax = cellVector[2]
# entirely above LDT
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}
return(dd)
}
comp = calc(r, degree.days.raster(LDT=15))
rs1 <- calc(r, sum)
rs2 <- calc(s, fun=function(x){x * 10})
rs2 <- calc(r, fun=function(x){x * 10})
runApp()
#Slightly modified version for use with raster calc function
degree.days.raster=function(x){
LDT = 15
Tmin = x[1]
Tmax = x[2]
#Tmin = cellVector[1]
#Tmax = cellVector[2]
# entirely above LDT
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}
return(dd)
}
comp = calc(r, degree.days.raster(x))
comp = calc(r, degree.days.raster())
comp = calc(r, degree.days.raster(...))
comp = calc(r, fun=degree.days.raster())
comp = calc(r, fun=degree.days.raster(x))
comp = calc(r, fun=degree.days.raster())
comp = calc(r, fun=degree.days.raster(x=x))
comp <- calc(r, fun=degree.days.raster(x=x))
rs4 <- calc(r, fun=function(x){x[1]+x[2]})
comp <- calc(r, degree.days.raster)
#Slightly modified version for use with raster calc function
degree.days.raster=function(Tmin = x[1], Tmax = x[2]){
LDT = 15
# Tmin = x[1]
# Tmax = x[2]
#Tmin = cellVector[1]
#Tmax = cellVector[2]
# entirely above LDT
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}
return(dd)
}
comp <- calc(r, degree.days.raster)
comp <- calc(r, degree.days.raster)
#Slightly modified version for use with raster calc function
degree.days.raster=function(x){
LDT = 15
Tmin = x[1]
Tmax = x[2]
#Tmin = cellVector[1]
#Tmax = cellVector[2]
# entirely above LDT
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}
return(dd)
}
comp <- calc(r, degree.days.raster)
#Slightly modified version for use with raster calc function
degree.days.raster=function(x){
LDT <- 15
Tmin <- x[1]
Tmax <- x[2]
#Tmin = cellVector[1]
#Tmax = cellVector[2]
# entirely above LDT
if(Tmin>=LDT) {dd = (Tmax+Tmin)/2-LDT}
# intercepted by LDT
## for single sine wave approximation
if(Tmin<LDT && Tmax>LDT){
alpha=(Tmax-Tmin)/2
theta1=asin(((LDT-(Tmax+Tmin))/alpha)*pi/180)
dd=1/pi*(((Tmax+Tmin)/2-LDT)*(pi/2-theta1)+alpha*cos(theta1))
if(!is.na(dd))if(dd<0){dd=0}
} #matches online calculation
# entirely below LDT
if(Tmax <= LDT){dd = 0}
return(dd)
}
comp <- calc(r, degree.days.raster)
# a = raster(r)
# rasterVis::levelplot(r)
rasterPlot(r$tmax)
# a = raster(r)
# rasterVis::levelplot(r)
raster::plot(r$tmax)
runApp()
Sys.Date
Sys.Date()
runApp()
as.Date(Sys.Date())
AOI = aoi_get(state = "conus")
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = as.Date(Sys.Date()))
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = unlist(Sys.Date()))
?getGridMET
Sys.Date()
Sys.Date()[1]
list(Sys.Date())
Sys.Date
Sys.Date()[[1]]
as.character(Sys.Date())
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = as.character(Sys.Date()))
Sys.Date()-1
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = Sys.Date()-1)
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = "2020-06-01")
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = "2020-05-31")
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = "2020-05-30")
p = getGridMET(AOI, param = c('tmax','tmin'), startDate = Sys.Date()-2)
runApp()
?addLegend
runApp()
?pal
?addLegend
runApp()
?addRasterImage
#comp = calc(r, degree.days.raster)
#raster::plot(r$tmax)
pal <- colorNumeric(c("#0C2C84", "#41B6C4", "#FFFFCC"), values(r),
na.color = "transparent")
runApp()
?addLegend
?layersControlOptions
runApp()
?addLegend
runApp()
?addLegend
runApp()
runApp()
runApp()
